

在Android平台上那些情况下会导致OOM问题？

1.根据Java的内存模型会出现内存溢出的内存有堆内存,方法区内存,虚拟机栈内存,native方法区内存;
2.一般说的OOM基本是针对堆内存;
3.对于堆内存的溢出的根本原因有两种
  一.app进程内存达到上限.
  二.手机可用内存不足.这种情况不是我们app消耗了很多内存,而是整个手机内存不足.
4.而我们需要解决的主要是app的内存达到上限
5.对于app达到内存上限只有两种情况
  一.申请内存速度超出gc释放内存的速度
  二.内存出现泄露,gc无法回收泄露的内存,导致可用内存越来越少.
6.对于申请内存岁都超出GC释放内存的速度主要有2种情况
  一.往内存中加载超大文件
  二.循环创建大量对象
7.一般申请内存的速度超出GC释放内存基本不会出现,内存泄漏才是出现问题的关键所在.
8.内存泄漏的常见场景
(1).资源对象没关闭造成内存泄漏(如:Cursor File等)
(2).全局集合类强引用没清理造成内存泄漏(特别是static修饰的集合)
(3).接收器.监听器注册没取消造成的内存泄漏。如广播,EventBus
(4).Activity的Context造成的内存泄漏,(可用使用ApplicationContext)
(5).单例中的static成员简介或直接持有了activity的引用
(6).非静态内部类持有父类的引用,如非静态handler持有activity的引用
9.怎么对内存进行优化呢
三个方向
(1)为应用申请更大的内存,把Manifest上的largdgeheap设置为true
(2)减少内存的使用
               1.使用优化后的集合对象,比如SpaseArray;
               2.使用微信的MMKV替代SharedPreference
               3.对于经常打log的地方使用StringBuilder来组拼,替代String拼接
               4.统一带有缓存的基础库,例如图片库
               5.给ImageView设置合适的尺寸图片,列表显示缩略图 点击放大
               6.优化业务架构设计,采用分页加载.
(3)避免内存泄漏
     编码规范上:
               1.资源对象用完一定关闭,最好加finally
               2.静态集合对象用完要清理
               3.接收器和监听器使用时候注册和取消一定要成对出现
               4.context使用注意生命周期,如果是静态类引用直接用ApplicationContext
               5.使用静态内部类
               6.结合业务场景,设置软引用,弱引用,确保对象可以在合适的时机回收.
               建设内存监控
               线下监控
               ①使用ArtHook检测图片尺寸是否超出imageview自身宽高的2倍
               ②编码阶段Memery Profile看app的内存使用情况，是否存在内存抖动，内存泄漏，结合Mat分析内存泄漏
               线上监控：
               ①上报app使用期间待机内存、重点模块内存、OOM率
               ②上报整体及重点模块的GC次数，GC时间
               ③使用LeakCannery自动化内存泄漏分析
               10、真的出现低内存，设置一个兜底策略
               低内存状态回调，根据不同的内存等级做一些事情，比如在最严重的等级清空所有的bitmap，关掉所有界面，直接强制把app跳转到主界面,
               相当于app重新启动了一次一样，这样就避免了系统Kill应用进程，与其让系统kill进程还不如浪费一些用户体验，自己主动回收内存

